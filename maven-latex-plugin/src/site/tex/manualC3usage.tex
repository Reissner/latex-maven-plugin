% !TEX root = manualLMP.tex

\chapter{Usage of Plugin and Task}\label{chap:usage}

% TBD: in the long run: plugin, task and standalone, or as a dependency
This software offers both, a maven plugin and an according ant task,
but the emphasis is on the maven plugin.
Thus, the sections of this chapter are either general
or apply to the maven plugin;
only Section~\ref{sec:usageAntTask} specifically refers to the ant task. 
Usage presupposes installation as described in Chapter~\ref{chap:install}
including settings in \texttt{pom.xml} 
as described in Section~\ref{sec:xmlPom} for the maven plugin 
and the settings in \texttt{build.xml} 
as described in Section~\ref{sec:xmlBuild} for the ant task.

This plugin may be used both if the \LaTeX-sources are ready 
to create ``final'' output from them 
and also to support development of the \LaTeX{} sources. 
Accordingly, this chapter has Section~\ref{sec:sources}
devoted to the form of the sources, including directory structure,
\LaTeX-files and others, mainly graphic files included
and a Section~\ref{sec:outputFormats} on exporting into various formats.

There is a very special usage, called development of documents,
which means while the document is under construction.
The features and goals tied to this phase
are collected in Section~\ref{sec:devel}.

In contrast, Section~\ref{sec:usageLifecycle}
is on usage of the maven plugin within the lifecycles.
This can be used during development of documents
but is more appropriate for small changes
or when development finished at a stage. 

%TBD: add links to all sections 
% also mention where the individual goals are treated. 

\section{The source files}\label{sec:sources}

The \LaTeX-files and also files included via \cmd{input}{} 
are searched in the \emph{TEX source directory} and subdirectories recursively. 
\index{TEX source directory}% chktex 24
By default, this is \texttt{./src/site/tex}, 
where ``\texttt{.}'' is the \emph{base directory} of this maven-project. 
\index{base directory}% chktex 24
The \LaTeX-files to be compiled top level, 
typically not inputted anywhere via \cmd{input}, 
are called \emph{\LaTeX{} main files}. 
As an example, 
in the \emph{TEX source directory} of this software, 
\texttt{manualLMP.tex} is a \LaTeX{} main file, 
whereas the file \texttt{header.tex} is not, although also a \LaTeX-file. 
% identification of the latex main file?
\LaTeX{} main files are detected automatically. 
\index{latex main file}% chktex 24

The included files may be again be \LaTeX-files, but also bibliography files, 
listings included by package \pkg{listings}, verbatim text included with \pkg{verbatim} 
and may be even code files to be executed via the package \pkg{pythontex}. 
\index{pythontex}% chktex 24
The great bulk of input files however, are graphic files in various formats. 
As regards the way the according files are included in \LaTeX-files, 
there are the following kinds of graphic formats, 
all included in the TEX source directory. 
%
\begin{enumerate}
\item
The first can be included into \LaTeX-files directly via \cmd{input}. 
These formats are essentially \LaTeX{}
and are defined in an according package. 
Examples are \pkg{eepic} described in~\cite{EEpic}
and above all \pkg{tikz} described in~\cite{TikzPGF}. 
\item
The second one via the command \cmd{includegraphics}{} 
defined by the package \pkg{graphicx} 
which is described in~\cite{GraX}. 
Chapter 2 therein mentions the supported drivers, 
among these are also \texttt{dvipdfm} and \texttt{dvipdfmx}. 
It is not the package but the driver 
which decides on the support of graphic formats. 
The dvipdfm user manual,~\cite{DviPdfMx} lists the allowed formats 
MetaPost (i.e.~\gls{mps}), postscript, 
\gls{pdf}, \gls{jpg} and \gls{png}. 
\item\label{it:transExp}
The third one must be transformed into a graphics format 
of one of the former two kinds using an external tool for transformation. 
Here, of course, only a limited support is possible, 
because there is a broad variety of formats. 
We have chosen
%
\begin{itemize}
\item
  the \gls{fig}-format described in~\cite{XFigF}
  because of its simplicity, 
\item
  the gnuplot format, described in~\cite{GnuPlot}, 
  because it allows computation of function plots, 
\item
  scalable vector graphics \gls{svg}-format specified in~\cite{Svg11}\footnote%
  { As the specification is hard to digest,
  we refer to the tutorial~\cite{SvgTut}. } 
  as it is important for construction and the counterpart of pixel oriented
  formats,
\item
  likewise, metapost (\gls{mp}-format),
  described in~\cite{MPost} because it is native to \LaTeX{} 
  and quite versatile 
\end{itemize}
\item\label{it:transImp}
The fourth kind of graphics formats 
has to be transformed into one of the kinds one or two 
but unlike in type three, this is not done explicitly 
by an external tool but by a latex-package during the \LaTeX-run. 
Note that, although not required to be explicitly transformed, 
those graphics files induce additional files 
by running \LaTeX.
Essentially, each of the abovementioned type of format
can be included that way but currently,
this is done for the \gls{svg}-format only
included by the package \pkg{svg} (see~\cite{SvgP}).
The author personally refrains from using packages like that
because of the lack of flexibility and further drawbacks. 
\item 
Finally, there is a way to include graphics which is not really a graphic format: 
In the course of running code, e.g.~by package \pkg{pythontex} in Python, 
as described in Section~\ref{sec:pythontex}, 
it is also possible to create computed graphics. 
It may be advisable to separate code into special files to be included via \cmd{input}, 
but it is not strictly required. 
In the long run it seems a good idea, to extend \pkg{pythontex} 
to read in code files, e.g.~in python directly. 
\end{enumerate}

% The \LaTeX-files and the graphic files belonging to a \LaTeX{} main file 
% are assumed to be in one single folder. 
% If one file is included by two different main files, 
% a link shall be used.
%TBC: True???

Note that unlike former versions of this software, 
the current version does not create a working directory 
by cloning the TEX source directory. 
Instead, it operates directly on the TEX source directory 
also creating intermediate files.
The advantage of processing that way is,
that this allows cooperation between this software
and other tool chains which are better suited for developing latex files.
Details are described in Section~\ref{sec:devel}.

The downside is that a file residing in the TEX source directory 
risks being overwritten by this software, 
if it does not stick to the rules. 
The rules are simple: 
For each graphic file, being transformed, 
i.e.~of types~\ref{it:transExp} or~\ref{it:transImp} above, 
additional files are created with the same name up to the suffix. 
Thus, for these graphic files no file with the same name 
up to the ending is allowed. 
The same is true for the \LaTeX{} main files.

Besides the \LaTeX-files and the graphics files
there is a third kind of file supported:
Bibliographies in bib-files.
This software treats them automatically. 


\section{Exporting in various formats and checking sources}\label{sec:outputFormats}


After having added the configuration of the plugin to the \texttt{pom.xml},
minimally the one given in Listing~\ref{lst:coords},
it can be used directly invoking maven through 
\texttt{mvn latex:cfg}. 
Here \texttt{latex} is the (short) name of the plugin 
and \texttt{cfg} is the goal. 
It can also be interpreted as \texttt{mvn $<$source$>$:$<$target$>$}: 
The source files are in \texttt{latex}-format and the target 
are read from the \emph{configuration} in the pom 
(\emph{configuration} is what \texttt{cfg} stands for) 
which is illustrated in Listing~\ref{lst:coordsConfig}. 
% TBD: clarify what about the ant task 

By default, the targets are \texttt{cfg}, \texttt{pdf} and \texttt{html}. 
The following Listing~\ref{lst:targetsAll} shows a configuration 
with the full range of output formats including in addition 
the OpenOffice document format \texttt{odt}, 
the MS word-formats \texttt{doc(x)} and \texttt{rtf} % chktex 36
and also plain text format \texttt{txt} in utf8 encoding. 

Note that the target \texttt{docx} converts by default into \gls{docx} 
but may also be configured to produce the old-fashioned \gls{doc} format. 

Be aware that the target \texttt{dvi} creates output in DVI format 
only for latex processors \lualatex{} and \pdflatex{}, 
whereas \xelatex{} creates the XDV (extended DVI) format for target \texttt{dvi}. 

%\lstset{language=xml, basicstyle=\small}
\begin{lstlisting}[language=xml, basicstyle=\small,
escapechar=|,
float, captionpos=b, label={lst:targetsAll}, 
caption={Configuration with full range output formats}]
<!-- create html and pdf and other formats from latex -->
<plugin>
  <groupId>|\groupId|/groupId>
  <artifactId>|\artifactId|</artifactId>
  <version>|\strippedVersionID|</version>
	
  <configuration>
    <settings>
      <targets>chk,pdf,dvi,html,odt,docx,rtf,txt</targets>
    </settings>
  </configuration>
</plugin>
\end{lstlisting}

Somehow special is the target \texttt{chk} 
which is mere checking without resulting output file. 
It just displays a warning if a rule is violated. 

The resulting files in the given output formats 
are copied to the site directory, 
which is \texttt{./target/site} in a default maven project. 

Sometimes it is more convenient 
to specify the output formats not via the pom 
but directly as a goal on the command line. 
In particular, one may write \texttt{mvn latex:pdf} to create documentation 
in PDF-format only.
Likewise, command \texttt{mvn latex:dvi} to get good old dvi/xdv files
or even \texttt{mvn latex:txt} for plain text, just as examples. 
Accordingly, \texttt{mvn latex:chk} performs a pure check. 
This occurs preferably in the context of documentation development. 
In particular, checking is treated separately in Section~\ref{subsec:develCheck}. 

Note that the \texttt{-X} switch activates debugging 
which results in a more verbose output. 
Example: \texttt{mvn -X latex:cfg}. 

% The code shows that allowed is only what is defined in enum Target. 
% Thus chk, which is a goal, is not output format. 
% This makes sense because Target specifies the files to be copied to the target filder. 

% in a sense this section mixes up output formats and goals. 
% For goal latex:cfg the output formats are as listed under config target. 
% Other goals, like latex:pdf specify a single output format. 

% Still other goals have no output format. These are 
% - latex:chk, although a check file is created. 
%   TBD: currently, there is no config to make chk run on latex main files. 
% - latex:grp, although graphic files are created but they are not exported. 
%   This may be done if source distributions are defined. 
% - latex:vrs, creating a version output or emitting warning if a version does not fit. 
% - latex:clr, for cleanup. 

% TBD: latex:grp does not fit: it is not an output format. 
% maybe it becomes output format if introducing source distributions 
% 
% Same is true for target clr. 



In a standard maven project, 
the above minimal configuration should be sufficient. 
Only if the folder structure deviates from the standard 
or if the \LaTeX{} sources require special configuration, 
parameters have to be given explicitly, 
because they deviate from the default values. 
Chapter~\ref{chap:settings} summarizes all available parameters, 
giving the default value and a description. 


For sake of uniformity, 
the name of the ant-task is \texttt{latex:cfg}, 
and it can be invoked via \texttt{ant latex:cfg}. 
Unlike the maven-plugin, the ant-task 
does not allow to specify a target on the command line. 
The \texttt{-d} switch activates debugging 
which results in a more verbose output. 
Example: \texttt{ant -d latex:cfg}. 

Whereas by default the target directory and in particular 
the target site directory with all output of this plugin is deleted 
in maven's \texttt{clean} life-cycle, 
the tools invoked by this software also create intermediate files 
in the source directory. 
By default, i.e.\@ for setting \texttt{<cleanUp>true</cleanUp>}, 
all files created in the source directory in the last run are cleaned. 
Nevertheless, for document development intermediate files are vital 
and so cleanup is frequently set to false. 
In this case, cleanup must be done in a separate goal, 
described in Section~\ref{subsec:develClean}. 

By default, the goal \texttt{clr} 
is also executed in maven's \texttt{clear} life-cycle. 

There is an according ant-task \texttt{latex:cfg} 
which can be invoked via \texttt{ant -d latex:cfg}. 
FIXME\@: ant  \texttt{latex:clr} has duplicate parameters. 
This can be fixed only by properties. 
Another problem is, to provide a complete subset of parameters 
which apply to \texttt{latex:cfg} and to \texttt{latex:cfg}, respectively. 

\section{Checking versions of converters}\label{sec:chkVersions}

\section{Injection of files}\label{sec:injFiles}

The goal \texttt{inj} is to inject files 
into the working directory \texttt{texSrcDirectory}. 

\begin{longtable}{|l|ll|}
  \toprule
  Name & File & explanation \\
  \midrule
  \midrule
  \endfirsthead%
  \bottomrule
  \caption{\label{tab:injections} Overview over all injections }
  \endlastfoot%
  latexmkrc   & \texttt{.latexmkrc}        & config file for \texttt{latexmk}   \\
  chktexrc    & \texttt{.chktexrc}         & config file for \texttt{chktex}         \\
  header      & \texttt{header.tex}        & header file for latex sources      \\
  vscodeExt   & \texttt{instVScode4tex.sh} & shell script to install VS Code extensions \\
  \end{longtable}

Table~\ref{tab:injections} shows the possible injections 
and the ones really to be performed are given in the configuration \texttt{injections}. 
The configuration is described in Table~\ref{tab:paramMisc} on page \pageref{tab:paramMisc}. 
It is a comma separated list and the default is \texttt{latexmkrc,chktexrc}. 

The file \texttt{.latexmkrc} tied to the injection \texttt{latexmkrc} 
is the configuration file for the build tool \texttt{latexmk} 
and likewise \texttt{.chktexrc} tied to the injection \texttt{chktexrc} 
is the configuration file for the style check tool \texttt{chktex}. 
Both tools are mainly used in document development 
as described in Sections~\ref{subsec:latexmk} and~\ref{subsec:develCheck}, 
but both tools may be used in a regular build also. 
So their respective configuration files must be injected 
in the build process before the \LaTeX{} build tools are invoked. 
Thus, goal \texttt{inj} has default phase \texttt{validate}. 
Note that \texttt{.latexmkrc} is adapted to the configuration of the current build, 
so that build with this software has the same result as direct invocation of \texttt{latexmk}. 
In the current version of this software, 
the injected \texttt{.latexmkrc} is not completely adapted to the configuration, 
and it is only intended to create PDF files. 
% TBD
In the future this shall change. 

The injection \texttt{header} is tied to the file \texttt{header.tex} 
which is intended to be included in each \LaTeX{} main file. 
Essentially it includes packages always needed. 
It is inspired by the packages \texttt{pandoc} includes by default 
according to \url{https://pandoc.org/MANUAL.html#creating-a-pdf}. 
As the configuration files described above, 
it is intended to be injected in phase \texttt{validate}. 

In the long run it could be adapted to the configuration as \texttt{.latexmkrc}, 
but currently it detects the use case as the latex converter or the target format 
and loads the according packages. 
Unlike \texttt{.latexmkrc}, it is not restricted to creating PDF. 
It is checked in conjunction with document classes \texttt{book} and \texttt{article}. 
**** TBD: mention also beamer class. **** 

The injections described so far are intended to be performed in phase \texttt{validate}  
as illustrated in Listing~\ref{lst:executions}. 
This is preferable, because the configuration files 
are adapted to the settings in each run. 

The last injection, \texttt{vscodeExt} injecting the file \texttt{instVScode4tex.sh} 
is used in a completely different way. 
If the editor VS Code is already installed, 
the script \texttt{instVScode4tex.sh} 
also given by Listing~\ref{lst:instVScode}, 
installs and updates all extensions the author used to write \LaTeX-code. 

\lstinputlisting[
language=bash, basicstyle=\tiny,
float, captionpos=b, label={lst:instVScode}, 
caption={Install script for extensions of VS Code. }]%
{instVScode4tex.sh}

Pasting \href{\urlSite fromTex/.latexmkrc}{.latexmkrc}, 
which is just Perl code, 
into VS Code one can see the highlighting, and a preview, 
of course provided the extensions given by Listing~\ref{lst:instVScode} are installed; 
The Perl script \texttt{.latexmkrc} is in fact the configuration file 
for the development tool \texttt{latexmk}. 
It is adapted to the settings of this plugin. 
Thus, by default it is created with each run if not present 
and is erased when cleaning. 

The file \texttt{.chktexrc} is to configure \texttt{chktex}. 
Its current state is given in Listing~\ref{lst:chktexrc} 
and \href{\urlSite fromTex/.chktexrc}{online}. 
The user is kindly asked to help to improve it. 

\lstinputlisting[basicstyle=\scriptsize,
float, captionpos=b, label={lst:chktexrc}, 
caption={The config file \texttt{.chktexrc} to check this manual. }]%
{.chktexrc}

It is observed that the packages loaded by various \LaTeX{} files 
have a huge overlap and that at the same time, although rare, 
exotic packages are loaded which may be replaced by standard ones. 
This hurts single source principle 
and at the same times makes it almost impossible 
for a build tool as this one, 
to make guarantees that it works still with the unexpected packages. 
This is, e.g.\@ because a package may write warnings 
in an unexpected way into some log file. 

Thus, a quite generic header file 
\href{\urlSite fromTex/header.tex}{header.tex} 
is also provided. 
It is written in a way, that it works for various generators, 
not only for \lualatex. 
With some restrictions it supports generation 
not only of PDF files but also of HTML\@. 
There would be a lot more to say, 
but have a look at it yourself. 



All these files are not only provided in the project site, 
but also by the injection goal of this plugin. 

Thus, they are available in a project using this latex plugin using the dependency plugin. 
The first \texttt{artifactItem} extracts \texttt{instVScode4tex.sh}. 
Since \texttt{instVScode4tex.sh} is not only to install extensions in VS Code 
but also to update them, it is convenient to have the script at hand. 
Project \url{https://github.com/Reissner/QMngMnt} 
uses the script for automation of installation and update. 


For document development the tool \texttt{latexmk} is a valuable build tool. 
Also, a linter like \texttt{chktex} is helpful. 


As described in~\cite{LatexMk23}, 
Section~``CONFIGURATION/INITIALIZATION (RC) FILES'', 
There are various configuration files \texttt{latexmkrc} or \texttt{.latexmkrc}, 
among these a global one, a local one referring to the enclosing folder 
and finally one specified by the command line option \texttt{-r}. 

Likewise,~\cite{ChkTeX22}, Section 6.1.3, shows that also \texttt{chktexrc} 
has a global configuration file \texttt{chktexrc} 
and a local one \texttt{.chktexrc} or \texttt{chktexrc}, 
depending on the operating system. 
Finally, a configuration file can be specified with the option \texttt{-l}, 
according to~\cite{ChkTeX22}, Section 6.1.1. 
Unfortunately, the ordering in which the configuration file given by option 
is read in compared to the other, is not clearly specified. 

For sake of reproducibility, we recommend restricting to the global configuration file 
which is tied to the installation and to a local file either respected because it is in the local folder 
or because it is given via a command line option. 

Caution: According to~\cite{ChkTeX22}, Section 6.1.3, 
as described, the local configuration file fits only for UNIX-like operating systems. 
For Windows and that like, \texttt{chktexrc} is expected. 
This can be realized with a link. 
For sake of reproducibility, we recommend only global config files, 
a local one in the current directory and maybe another one 
specified with the option \texttt{-r} as described below. 
In order to have the same \texttt{.chktexrc} for all main files in different folders, 
one shall use a central \texttt{.chktexrc}, e.g.\@ \texttt{src/site/tex/.chktexrc}, 
and then either set a link to it from all folders with latex main files 
or just use the \texttt{-r}. 
Unfortunately,~\cite{ChkTeX22} does not tell about the ordering 
in which the configuration file given by the option \texttt{-r} is read in. 

This maven plugin offers a goal \texttt{inj} 
to create the configuration files \texttt{.latexmkrc}, \texttt{.chktexrc} and further files, 
all in the latex source directory. 
In particular \texttt{.latexmkrc} is adapted to the current settings of this plugin. 
That way, \texttt{latexmk} behaves the same as does this plugin. 
Similarly, for \texttt{chktex}. 
Note that these files are written only if either no file is overwritten 
or only files are overwritten which were written by this plugin. 
Self-written files are recognized by the headline. 
If this cannot be read or in some other exotic conditions, 
it cannot be ensured that the files are written by this software, 
and so they are not overwritten. 
In case of a doubt, a warning is displayed. 








As mentioned above, the intention behind is, 
to keep \texttt{latexmk} and this latex plugin synchronized 
by providing properties in the pom and using them as settings when configuring the latex plugin 
and at the same time to filter the raw \texttt{.latexmkrc}. 
Currently, not all possible settings of this plugin 
are taken into account in the raw \texttt{.latexmkrc}. 
It is advisable, to use a raw \texttt{.latexmkrc} taking only parameters into account, 
which are explicitly configured for the latex plugin. 
So the given raw \texttt{.latexmkrc} is no more than a hint. 





\section{Development of documents}\label{sec:devel}

The term ``development of documents'' is coined by the author 
and reflects that writing a document 
resembles developing software 
in that it is an iterative process consisting in producing pieces of information, 
checking, modifying, correcting, erasing it, checking again\dots. 
After initial creation, is an iterative process 
like a dialog between the author and its work. 

This is true of course independent of the tools used, 
but some tools support this process better than others. 
For document development the ideal are WYSIWYG (``what you see is what you get'') editors, 
which should maybe be better called WYRIWYR (``what you write is what you read''), 
or, taking also drawings into account, IisO (``input is output''). %TBD: maybe better glossary 
For software development the ideal languages are prototyping languages, interpreted at least. 

From that point of view, \LaTeX{} and friends is the worst conceivable choice: 
%
\begin{itemize}
  \item
  You write in an editor, but you read off from a viewer. 
  So you must permanently switch your attention. 
  \item
  You write a sequence of commands, but you read text, formulae, drawings. 
  In a sense you program the appearance of a page or site. 

  This discrepancy becomes particularly apparent if creating a drawing in \LaTeX, 
  e.g.\@ with TikZ, because even drawings are described or programmed quite formally. 
  \item
  You cannot just see instantly the result of your work; 
  first you have to trigger a compilation process and wait some time. 
  So, besides an editor and a viewer you also need some kind of console. 
  It is even worse: 
  Typically, based on the console output you must either rerun the compiler 
  or run some auxiliary program, even more of them 
  and then again the compiler, maybe several times. 
  The decision whether the viewer shows the final result already, 
  or whether another command has to be issued and if so which one, 
  is based on the console output. 
  So part of your attention must be on the console also. 
  The console is also used to issue the next command. 
  \item 
  The compilation process may go wrong or be in a sense deficient, 
  so what you need is observing logs, either on the console or in a log file. 
  Even if the input is accepted by build tools even without warning, 
  still there may be something wrong. 
  The \LaTeX{} tools do not include any spell checking or grammar checking. 
  Since \LaTeX{} documents are in a sense programmed, 
  an additional burden is the need for a kind of linting, 
  which is done, e.g.\@ by \texttt{chktex}. 
  This must be invoked manually and yields another log file, 
  although no output. 
\end{itemize}

The situation is visualized in Figure~\ref{fig:docDevelBase}. 
It is no UML diagram although using elements of UML\@. 
The developer of the document is visualized as a stick figure 
and the tools used for development are the boxes surrounding it,
resembling instances in a UML class diagram. 
Besides the tool under consideration, the according files are shown. 
The console is to invoke conversion commands like \lualatex. 
This shows already, that the user does not face a single counterpart, 
but has to juggle with a bunch of tools at once. 
The arrows represent data flows and this data is commands at least partially, 
if the lines are solid, else they are dotted. 

This explains the need for tools and techniques to mitigate the situation. 

Seemingly, this \LaTeX-builder is not to contribute to document development, 
because it is used after the end of the development process, 
automating the compilation process. 
But since compilation may fail and because it is also a checker tool, 
supervising even warnings, e.g.\@ on bad boxes, and by default invoking \texttt{chktex} 
and monitoring its log file, 
it may be the start point for another loop in the development process. 

Before describing the contribution of this \LaTeX-builder 
to the process of document development, 
let us describe the process of document development in more detail, 
in particular the other tools supporting document development and their interaction. 
With this background in mind, it is easy to describe the role of the \LaTeX-builder 
in the team of development tools. 

\begin{figure}
  \centering
  \IfPackageLoadedTF{tex4ht}{%
should be a picture 
}{ 
%\includegraphics{F4_05someMetapost1.mps}
\includegraphics{F3_01texUsagePlain.mps}
}
  \caption{\label{fig:docDevelBase}Document development with base tools}
\end{figure}

The minimum needed to develop a document in \LaTeX{} 
are an editor, an according viewer and the \LaTeX{} tools for build and check 
as described in Section~\ref{subsec:editViewLatex}. 
As described above, using this basic tools directly 
distracts much of the attention of the author/developer 
from the content. 
Thus, it is a good idea to use a tool to orchestrate the \LaTeX{} tools. 
The author of this software prefers the orchestration tool \texttt{latexmk} 
which is described in Section~\ref{subsec:latexmk}. 

The check tool \texttt{chktex} and the according goal \texttt{chk} 
are already described in Section~\ref{sec:outputFormats}. 
Nevertheless, the aspects of checking 
in the context of document development is treated separately 
in Section~\ref{subsec:develCheck}. 

The goals \texttt{grp} and \texttt{clr} 
described in Sections~\ref{subsec:develGraph} and~\ref{subsec:develClean} 
make sense only in the context of document development. 
For details see these sections. 

Finally, Section~\ref{subsec:develConfig} 
is on installing extensions for document development on the editor VS Code. 
To that end, this software provides an installation script. 






\subsection{Editors, viewers and \LaTeX}\label{subsec:editViewLatex}

The author recommends using VS Code to write \LaTeX{} documents 
and to view the results on \texttt{okular}. 

Editor VS Code with extensions in conjunction with viewer. 
Mention also Emacs with AUC\TeX. 
Point to installation script for extensions described in Section~\ref{subsec:develConfig}. 
Extensions of VS Code are mainly to highlight the code of the various file types, 
but the central extension is \texttt{james-yu.latex-workshop} 
which also provides build functionality. 

  For viewer, we use \texttt{okular}. 
  Settings is settings configure okular. 
  Then in tab \texttt{General} we 
  %
  \begin{itemize}
    \item deselect show backend selection dialog 
    \item select reload document on file change 
  \end{itemize}

Describe forward search and backward search. 
Also mention clean goal described in more detail in Section~\ref{subsec:develClean}

Mention a way to speed up compilation: using includes rather than imports. 
As a consequence, additional AUX files are created. 
These are also cleaned. 

The latex processor may fail. 
Typically, the latex converter must be invoked more than once 
and besides the latex converter some further auxiliary programs must be run. 
What to do is displayed on the console. 
Most of the programs write success messages and more detailed information 
containing error messages, warning or just information messages in their respective log files. 
In the course of 


Next talk about orchestration: 
The user is freed from deciding which of the many auxiliary programs are to be invoked next 
and whether the latex converter is to be invoked once more 
in order to emit final correct output. 

There is another tool doing this work, \texttt{latexmk}. 
Essentially, it is better suited to document development, 
because it allows easily to build a single document only and is considerably faster 
because no overhead from maven or ant, 
and it can be run in \texttt{nonstopmode}. 

Still, \LaTeX-builder has its place in conjunction with \texttt{latexmk}. 


\subsection{The build tool \texttt{latexmk}}\label{subsec:latexmk}

TBD: Describe the build tool \texttt{latexmk} but also its deficiencies, 
i.e. what this \LaTeX-builder offers in addition. 
Essentially, there are two aspects: 
The build processes are different and the \LaTeX-builder is much faster 
in conjunction with certain graphics 
as used e.g. in this manual. 
The main aspect is supervision of the build process: 
\texttt{latexmk} focuses on mere build success, 
but does not notify of warnings. 
So the build process may complete, but the result may be inappropriate. 

Here also links to goal \texttt{grp} creating graphics files 
described in Section~\ref{subsec:develGraph} 
and to Section~\ref{sec:injFiles} on file injection are in place. 
Also link on goal \texttt{clr} to clear created files 
described in Section~\ref{subsec:develClean}. 

\subsection{Checks in the context of document development}\label{subsec:develCheck}

TBD: rework 

target and goal \texttt{chk} just invoke the tool \texttt{chktex} 
and checks for a finding. 
That way it is a quality control in the course of the build process, 
but also the entry point for further development. 

As described in Section~\ref{sec:injFiles}, 
the configuration file \texttt{.chktecrc} for \texttt{chktex} is injected. 

In case of findings, a log file is written which can be analyzed. 
Then alternately the source can be corrected 
and \texttt{chktex} can be invoked directly. 
Since the configuration file is as in the build run, 
the results are the same. 




\subsection{Goal Graphics \texttt{grp}}\label{subsec:develGraph}

Hint to relation with latexmk. 
needs mvn validate \& mvn latex:grp. 

For creating the graphic files in the TEX source directory, 
there is a goal \emph{graphics}, invoked by \texttt{mvn latex:grp}. 
This goal does not create any output in the site directory. 
Instead, it populates the source directories 
with graphic files which can be directly included into the \LaTeX-file 
and so it allows to run the \LaTeX-compiler on the latex main files 
from within a development environment. 
Thus, the goal \emph{graphics} is thus a vital feature 
for development of documents. 


Note that in general \texttt{mvn clean validate latex:grp} 
creates all files necessary to compile with a latex converter like \lualatex{} 
and also to compile smoothly with \texttt{latexmk}. 



\subsection{Goal Clear \texttt{clr}}\label{subsec:develClean}

Maybe the material is not enough for a separate section. 
Important to ensure independence. 

Finally, there is another target for clearing the TEX source directory 
recursively, invoked by \texttt{mvn latex:clr}. 
For more details on the last three goals, see Section~\ref{sec:devel}. 

Hint to goal graphic. 

As is described in more detail in Section~\ref{sec:devel}, 
this software creates target documents and also intermediate files 
in the TEX source directory, at least with cleanup disabled. 
To eliminate the created files from the source directory, 
just type \texttt{mvn latex:clr}. 

cleanup refers also to injections. 

Likewise, goal \texttt{clr} deletes these configuration files 
if they were definitively written by this plugin. 
If this is proved to be false or a proof is not possible, 
the configuration files are not deleted. 
As for goal \texttt{inj}, in case of a doubt, a warning is displayed. 





\subsection{Installation and Configuration}\label{subsec:develConfig}

TBD\@: rework: maybe better describe the goal \texttt{inj}. 
The goal \texttt{inj} is to create a set of files, 
partially adapted to the current configuration. 

A first description of the injection goal is given by 
%
\begin{verbatim}
mvn latex:help -Ddetail -Dgoal=inj
\end{verbatim}
%
which yields a list of files which can be injected. 

By default, it is tied to lifecycle phase \texttt{validate} 
and comprises the set of injections \texttt{latexmkrc,chktexrc}. 

The first we treat is injection \texttt{vscodeExt} 
injecting a file \texttt{instVScode4tex.sh} in the TEX source directory. 
Typically, this is not injected during a lifecycle, 
but when installing or updating extensions for VS Code 
used during document development. 
Thus, typically it is invoked in the form 
%
\begin{verbatim}
  mvn latex:inj -Dlatex.injections=vscodeExt
\end{verbatim}

In the default configuration, this creates an executable file 
%
\begin{verbatim}
  src/site/tex/instVScode4tex.sh
\end{verbatim}
%
using bash shell. 
The extensions 



Install script for installing extensions for VS Code 
helping in developing \LaTeX{} documents. 


In addition, configuration scripts for \texttt{latexmk} and \texttt{chktex}. 
Also describe how to use. 



\subsection{Miscellaneous}% TBD: This is to be removed in the long run. 



During development, it is comfortable, 
to have the log-file in the same directory as the \LaTeX{} main file. 
Also, if PDF- and TEX-files are synchronized, 
% FIXME: reference to package 
also the PDF-file should be in the same directory. 
Likewise, files in graphic formats 
which cannot be included into a \LaTeX-file without conversion, 
that converted file shall be in the same directory as the original one. 
So, all files, manually created files 
and files arising from automatic conversions 
shall be in the same folder, at least during development. 
Also, typically, one wants to mix creation by this maven-plugin or ant-task 
with at least partial creation through external tools. 
For example, if writing \LaTeX-files with Emacs, 
it is much more convenient, to compile the \LaTeX{} main file 
via \pdflatex{} from within Emacs 
or to create a PDF-file from a \gls{fig}-file 
through \texttt{xfig}'s export dialog, 
than using this maven-plugin or this ant-task. 
Also, these tools work best, if all is in one folder. 

On the other hand, 
conventionally, in a maven project, 
sources are held in folder \texttt{src}, 
whereas created files occur in the folder \texttt{target}. 
Likewise for ant. 
The compromise, this maven-plugin and this ant-task take, 
is, that at the end of a run, 
at most the files present at the beginning of the run 
may be present in the source directory. 
So, this software builds in the following steps: 
%
\begin{itemize}
\item
Store a list of all files present at the beginning of a run.
\item
Process all graphics files of the formats requiring preprocessing.
\item
Determine the \LaTeX{} main files.
\item
Run the \LaTeX{} converter, e.g.~the one creating PDF-output or DOCX-output.
This may include running auxiliary programs like \texttt{bibtex} or \texttt{pythontex} 
and also rerunning the \LaTeX{} converter several times. 
\item
Copy the result files (if any) into the target folder.
\item
Remove all files not present at the beginning of a run, by default. 
% FIXME: maybe different for goal chk. 
\end{itemize}

To keep e.g.~the resulting PDF, 
just create it via compilation through Emacs, 
even if not all graphic files to be included are present 
or just by a \texttt{touch}-command. 
Then in the next run of this plugin, 
this PDF will be re-created, 
that time complete with the graphics output. 
That way, synchronization between \LaTeX- and PDF-files is possible. 
Likewise, to keep the log-file or the aux-file, just touch it. 
This technique is really valuable for debugging. 

To keep all created files after a run of this maven-plugin, 
set the parameter \texttt{cleanUp} in the pom 
to \texttt{false} as illustrated in Listing~\ref{lst:noCleanup}. 
For the ant-task likewise. 

%\lstset{language=xml, basicstyle=\small}
\begin{lstlisting}[language=xml, basicstyle=\small,
escapechar=|,
float=b, captionpos=b, label={lst:noCleanup},
caption={Configuration without cleanup}]
<!-- create html and pdf and other formats from latex -->
<plugin>
  <groupId>|\groupId|</groupId>
  <artifactId>|\artifactId|</artifactId>
  <version>|\strippedVersionID|</version>
	
  <configuration>
    <settings>
      <targets>pdf</targets>
      <cleanUp>false</cleanUp>
    </settings>
  </configuration>
</plugin>
\end{lstlisting}


But how can one get rid of all these newly created files? 
That is what is the goal \texttt{latex:clr} is for: 
% 
\texttt{mvn latex:clr}
%
removes all created graphic files 
and for each latex main file, it removes all files with ``similar'' names
including log files, index files and that like.
Typically, this suffices, to remove all files created. 
If not, 
try to modify parameter \texttt{\$patternCreatedFromLatexMain} 
in the pom accordingly. 
If this does not help either, please inform the developer of this software. 
Of course, if further software is used which creates additional files, 
like Emacs creates a folder \texttt{auto}, 
these files cannot be removed by this maven-plugin or this ant-task.
Note that \texttt{latex:clr}
also removes exported files as listed in Section~\ref{sec:outputFormats}
from the target folder. 

During development of a \LaTeX-main file, 
it is often more convenient to compile from within an editor like Emacs. 
The problem is, that compilation fails if the graphic files are missing. 
This is what the goal \emph{graphics} accessible via 
% 
\begin{Verbatim}
mvn latex:grp
\end{Verbatim}
%
is for: 
It creates all graphic files required to compile the \LaTeX-main files. 

Still this does not create a bibliography, an index or a glossary. 
With \emph{auctex}\index{auctex}, an Emacs-package for editing \LaTeX, 
bibliography and index are well-supported. 
To create a glossary, auctex has to be modified a little. 

%FIXME\@: include this into auctex. 

That way also the log-files required are created: 
In case of this manual, 
the files \texttt{manualLMP.xxx} are created 
where \texttt{xxx} is 
%
\begin{itemize}
\item
\texttt{log} for \LaTeX, 
\item
\texttt{blg} for \texttt{BibTeX}, 
\item
\texttt{glg} for \texttt{makeglossaries} and 
\item
\texttt{ilg} for \texttt{makeindex}. 
\end{itemize}

The last goal regularly used for development of documentation is \emph{check}. 
It is invoked via 
% 
\begin{Verbatim}
mvn latex:chk
\end{Verbatim}
%
and runs \texttt{chktex}, described in~\cite{ChkTeX22}, 
on each latex main file 
after having created graphic files as for goal \emph{graphics}. 
As a result, a log-file with suffix \texttt{.clg} is created 
but not copied to the target folder. 
If the log-file contains an entry, 
an according message is logged. 
% FIXME: there is a lot more to do here. 
Note that, with default configuration, 
\texttt{chktex} requires the \LaTeX-package \pkg{booktabs} 
described in~\cite{BooktP}. 

Besides the basic configuration packaged with \texttt{chktex}, 
there can be an additional configuration file \texttt{.chktexrc} 
which partially overwrites variables set by the basic configuration file, 
partially, for list-valued variables, adds entries. 
Section~\ref{sec:xmlPom} describes how to access the \texttt{.chktexrc} 
with which this manual is checked and 
details to the form of \texttt{.chktexrc} can be found in~\cite{ChkTeX22},~Section 6.1.5.  


% rsvg-convert -f pdf -o t.pdf t.svg
% inkscape t.svg --export-pdf=t.pdf
% convert file.svgz file.pdf 
% rasterizer -m application/pdf file.svgz -d file.pdf
% cairosvg in.svg -o out.pdf
% yyy

Finally, we have the goal \texttt{latex:vrs}
to display meta information, above all version information:
% 
\begin{Verbatim}
mvn latex:vrs
\end{Verbatim}
%
displays something like what is displayed in Listing~\ref{lst:vrsOut}. 
Besides information on this software including version and even git commits, 
there are information on so-called registered converters, 
i.e.\@ converters intended to be invoked by this software. 

The goal yields a full list of registered converters, 
signifying which of them are excluded 
according to parameter \texttt{convertersExcluded}, 
which are not installed, 
and for each of the rest, the actual version, the allowed range 
and a warning if the actual version is out of range. 

The parameter \texttt{convertersExcluded} 
is described in Table~\ref{tab:paramGen} on page~\pageref{tab:paramGen}. 
Excluded converters are prevented from being used: 
if tried, Exception TSS07 
described in Table~\ref{tab:TSS} on page~\pageref{tab:TSS} is thrown. 
If a converter is not installed, but tired to be used, 
this kind of failure is obvious. 
Only if a converter is used with an unintended version bears some risk. 
Note that also unregistered converters can be used; 
but then the user is responsible to provide an appropriate version. 
An example for an unregistered converter 
is given in Table~\ref{tab:paramPythontex} on page~\pageref{tab:paramPythontex}: 
\texttt{pythontexW:pythontex} 
indicating the converter \texttt{pythontexW} with category \texttt{pythontex}. 


As one can see, a warning WMI02 indicates 
that the version of a converter is out of the intended range, 
provided, the converter is installed, and it is not excluded 
according to the configuration \texttt{convertersExcluded}.

Note that in the given version and in the installation of the author,
of course, all converters are installed and are up-to-date
to be able to check validity.
The according messages are forced for illustration only. 
For a user of this software which does no development, 
of course only converters need to be installed which are really needed. 
% TBC: what is an interface of a converter?
% Note that \texttt{makeindex} is not in the list.
% This is because it is not possible
% to regularly check the version of that application.
% It may be an option to use \texttt{upmendex} instead,
% although in beta state at time of this writing
% and not completely compatible.
% According to \cite{UpMendex}, \cite{MkIdxMoe}
% and further research,
% \texttt{upmendex} does not support options \texttt{-T} and \texttt{-L}
% and does interprete \texttt{-g} differently,
% namely as japanese instead of german. 


% TBD: make this listing dynamic 
% TBD: this is almost duplicate of lst:version.properites
% maybe one shall be eliminated. 
\begin{lstlisting}[basicstyle=\tiny,
float, captionpos=b, label={lst:vrsOut}, 
caption={Output of goal \texttt{latex:vrs}}]
[INFO] --- latex:2.0-SNAPSHOT:vrs (default-cli) @ latex-maven-plugin ---
[INFO] Manifest properties: 
[INFO] MANIFEST: (1.0)
[INFO]        Implementation-Version: '2.0-SNAPSHOT'
[INFO] PackageImplementation-Version: '2.0-SNAPSHOT'
[INFO] pom properties:
[INFO] coordinate.groupId:    'eu.simuline.m2latex'
[INFO] coordinate.artifactId: 'latex-maven-plugin'
[INFO] coordinate.version:    '2.0-SNAPSHOT'
[INFO] git properties: 
[INFO] build version:  '2.0-SNAPSHOT'
[INFO] commit id desc: 'latex-maven-plugin-1.8-209-g5ac27b7-dirty'
[INFO] buildTime:      '2023-06-25T23:31:20+0200'
[INFO] tool versions: 
[INFO] ?warn?    command             'actual version'(not)in[expected version interval]
[INFO]           pdflatex:           '1.40.25'in[1.40.21;1.40.25]
[INFO]           lualatex:           '1.17.0'in[1.12.0;1.17.0]
[INFO]           xelatex:            '0.999995'in[0.999992;0.999995]
[INFO]           latex2rtf:          '2.3.18 r1267'in[2.3.16 r1254;2.3.18 r1267]
[INFO]           odt2doc:            '0.9.0'in[0.9.0]
[INFO]           pdftotext:          '23.06.0'in[21.04.0;23.06.0]
[INFO]           dvips:              '2023.1'in[2020.1;2023.1]
[INFO]           dvipdfm:            '20220710'in[20210318;20220710]
[INFO]           dvipdfmx:           '20220710'in[20200315;20220710]
[INFO]           xdvipdfmx:          '20220710'in[20200315;20220710]
[INFO]           dvipdft:            '20090604.0046'in[20090604.0046]
[INFO]           gs:                 '9.56.1'in[9.52.0;9.56.1]
[INFO]           chktex:             '1.7.8'in[1.7.8]
[INFO]           diff-pdf-visually:  '1.7.0'in[1.6.4;1.7.0]
[INFO]           diff-pdf:           '300'in[300]
[INFO]           diff:               '3.10'in[3.8;3.10]
[INFO]           pdfinfo:            '23.06.0'in[22.01.0;23.06.0]
[INFO]           exiftool:           '12.63'in[12.39;12.63]
[INFO]           bibtex:             '0.99d'in[0.99d]
[INFO]           bibtexu:            '4.00'in[4.00;4.00]
[INFO]           bibtex8:            '4.00'in[4.00;4.00]
[WARNING] WMI02: makeindex:          '2.17'not in[2.15;2.16]
[INFO]           splitindex:         '0.1'in[0.1]
[INFO]           makeglossaries:     '4.51'in[4.45;4.51]
[INFO]           pythontex:          '0.18'in[0.17;0.18]
[INFO]           depythontex:        '0.18'in[0.17;0.18]
[INFO]           mpost:              '2.02'in[2.00;2.02]
[INFO]           ebb:                '20220710'in[20200315;20220710]
[INFO]           gnuplot:            '5.4 patchlevel 8'in[5.4 patchlevel 0;5.4 patchlevel 8]
[INFO]           inkscape:           '1.2.2'in[1.0.2;1.2.2]
[INFO]           fig2dev:            '3.2.8b'in[3.2.7b;3.2.8b]
[INFO] tools excluded: 
[INFO] upmendex, xindy
[INFO] tools not found: 
[INFO] latexmk
[INFO] ------------------------------------------------------------------------
\end{lstlisting}
%[INFO]           upmendex:           '1.00'in[0.54;1.00]
%[INFO]           xindy:              '2.5.1'in[2.5.1]



Another aspect of document development is integration with other tools. 

Document development starts with the editor. 
Above the Emacs editor enhanced with auctex was mentioned. 
We recommend VS Code in conjunction with several extensions. 
If VS Code itself is already installed 
the script in Listing~\ref{lst:instVScode} on page~\pageref{lst:instVScode}  
installs and updates all extensions 
the author used to develop this manual. 
The core extension is \texttt{latex workshop}, 
the others are mainly used for editing graphic files. 
For details see Section~\ref{sec:xmlPom}. 




A valuable standalone build tool is \texttt{latexmk}. 
It can even run in background. 
This manual can also be compiled with \texttt{latexmk} 
but only with adapted configuration file \texttt{.latexmkrc}. 
For details see Section~\ref{sec:xmlPom}. 




% to be included. 
This software and \texttt{latexmk} follow a different philosophy in finding dependencies: 
Whereas this software creates image files in advance before invoking a latex converter, 
\texttt{latexmk} first calls the latex converter in nonstopmode 
to avoid a stop because of a missing file. 
Then the file is created using the appropriate rule (hopefully unique) 
and the converter is run again, 
this time passing the inclusion of the first created files 
failing at the next one. 
This goes on that way until the last included file is created. 
Then the latex converter runs through without failure caused by missing files. 

There are two problems with this: 
This yields a huge number of runs for the converter 
which is time-consuming 
and there is at least one kind of inclusion which does not work that way: 
inclusion with \texttt{\textbackslash{}lstinputlisting} 
provided by \pkg{listings}. 
In fact, i have an email from J. Hoffmann, author of listings 
telling that there are more packages with the same problem. 
To be checked: \pkg{fancyvrb} and \pkg{moreverb}. 
Nevertheless, all other ways of inclusion \emph{used by this manual} 
like the one with \texttt{\textbackslash{}import} 
seem to work fine. 

The current workaround is illustrated in Listing~\ref{lst:fileIfExists} 
modifying \pkg{listings}' output to make it digestible for \texttt{latexmk}. 

\lstinputlisting[linerange={124-141},
language=tex, basicstyle=\scriptsize,
float, captionpos=b, label={lst:fileIfExists}, 
caption={Patch of the \texttt{listings} package given by the header file. }]%
{header.tex}

Still some generalization in \texttt{latexmk} could spare this modification. 

Another point is, that currently for each file \texttt{latexmk} creates with a separate rule, 
another run of the latex processor is required: 
The initial run is interrupted with the first missing file. 
Then that file is created by an appropriate rule and the latex processor is rerun 
failing with the next missing file. 
That way the process goes on until the last file is created with a rule. 
Of course this procedure is quite time-consuming, so an alternative is required. 




% TBD: link? 

\section{Goals in the maven lifecycle}\label{sec:usageLifecycle}

The goal \texttt{latex:cfg} exporting in the formats configured
is tied to the lifecycle phase \texttt{site} so is invoked
when commanding
%
\begin{Verbatim}[fontsize=\scriptsize]
mvn site
\end{Verbatim}
%
or subsequent phase.

Also, the goal \texttt{latex:clr} cleaning created files
both from source directory and from target directory
is tied to phase \texttt{clean} so is invoked
when commanding
%
\begin{Verbatim}[fontsize=\scriptsize]
mvn clean
\end{Verbatim}

Finally, the goal \texttt{latex:vrs} displaying versions of converters 
and the goal \texttt{latex:inj} injecting a set of files 
depending on the configuration 
are tied to the phase \texttt{validate}. 
Thus, it is thus invoked when commanding
%
\begin{Verbatim}[fontsize=\scriptsize]
mvn validate
\end{Verbatim}
%
which is invoked not only in installation, but also by the site plugin.
This ensures, that the converters are checked for correct version
before being used. 
Note that by default, \texttt{mvn latex:vrs} displays complete version info,
whereas \texttt{mvn validate} only displays warnings if appropriate. 
This is, because in the first case the plugin runs with the default \texttt{versionsWarnOnly=true} 
whereas in the second case, is configured with \texttt{versionsWarnOnly=false} 
as in Listing~\ref{lst:executions}. 




\section{The ant-tasks}\label{sec:usageAntTask}


Section~\ref{sec:outputFormats} treats goal \texttt{cfg} 
to create output from one source in various formats 
and also check which is without output. 
The target formats and also the checks are specified in the parameter \texttt{targets}. 

There is an according ant task \texttt{cfg} doing the same also based on parameter \texttt{targets}. 
Whereas the maven plugin provides separate goals for each target, 
the ant-task has no such convenience feature. 
Section~\ref{sec:outputFormats} briefly mentions goal \texttt{clr} 
used for cleanup. 
There is an according ant-task relying on according parameters. 
Note that the ant task does not support very much of document development, 
but it is likely, that the user performs document development 
and runs other programs than the ant task on the sources. 
In this case, the \texttt{clr} task is vital. 


If this ant-task is used in an ant project 
with folder structure conforming with a maven project 
and if the \LaTeX{} sources do not require a special configuration, 
the above configuration is sufficient. 
Otherwise, parameters have to be given explicitly 
overwriting the default values. 

